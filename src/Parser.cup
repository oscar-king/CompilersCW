/* ----------------------Preliminary Declarations Section--------------------*/
import java_cup.runtime.*;

/* Parser code to change the way the parser reports errors (include
   line and column number of the error). */
parser code {:
    public boolean syntaxErrors;

    public void syntax_error(Symbol current_token) {
        syntaxErrors = true;
            report_error( "Syntax error at line " + (current_token.left+1) + ", column " + current_token.right + " " + current_token.value + "\n", null);
    }
:};



/* ------------Declaration of Terminals and Non Terminals Section----------- */

//Data Types
terminal           INT, BOOL, RAT, FLOAT, CHAR, DICT, SEQ, SET;

//Other keywords
terminal           THREAD, TOP, FUNC, TDEF, FDEF, RETURN, ALIAS;

//Loops
terminal           IF, FI, THEN, ELSE, WHILE, DO, OD, ELIF, FORALL, IN, BREAK;

//Built in functions
terminal           READ, PRINT, MAIN;

//Operators
terminal           ASSIGN, ARROW, NOT, AND, OR, TRUE, FALSE, INTERSECTION, PIPE, DIFFERENCE, CONCAT;
terminal           NOTEQ, EQ, LT, GT, LTEQ, GTEQ;
terminal           PLUS, MINUS, MULT, DIV, EXPO;

//Punctuation
terminal           LPAREN, RPAREN, LBRACE, RBRACE, LBRACK, RBRACK, SEMI, COLON, COMMA, DOT;

//Literals
terminal           IDENTIFIER, INT_LIT, CHAR_LIT, RAT_LIT, STRING_LIT, FLOAT_LIT;

//High Level
nonterminal        program, main, statement_list, identifier, idWithIndex;

//Declarations
nonterminal        declaration, type_and_id, assignment, tdef, fdef, alias, lambda, set_declaration, dict_declaration, seq_declaration;

//Types
non terminal       type, dicttype, seqtype;

//Lists
nonterminal        expression_list, declaration_list, statement_list_with_break;
nonterminal        arg_list, args, param_list, params;

//literals
non terminal       dict_lit, seq_lit, boolean, number, set_lit;

//Loops
non terminal       do, forall, while, break,  do_with_break, looping;

//Statements and expressions
non terminal       function_call, return_type, if_statement, if_statement_break,return_statement, statement_with_break, body_with_break;
non terminal       dictbody, seqbody, statement, base_statement, statement_list_main, main_statement;
non terminal       expression, operator, multithreading;

//Functions
non terminal       print, read, id_list_helper, id_list;

//Helpers
nonterminal        idWithIndexHelp, indexCall, field_access, param_list_helper, elif_break, elif, dictbody_helper, expression_list_helper, lbrace_statement_list;

/* ------------Precedences----------- */
precedence left OR;
precedence left AND;
precedence nonassoc EQ, NOTEQ;
precedence nonassoc LT, LTEQ, GT, GTEQ;
precedence left CONCAT, PIPE, DIFFERENCE, INTERSECTION;
precedence right PLUS, MINUS;
precedence left  MULT, DIV;
precedence right IN, EXPO;
precedence nonassoc NOT;
precedence right ARROW;
precedence left LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE;
precedence right INT, DICT, SET, SEQ, FLOAT, RAT, CHAR, BOOL, TOP;
precedence left COMMA, SEMI;
precedence right DOT;

start with program;

//TODO 2. nested elifs 3. nested lambdas 4. LPAREN and RPAREN issue 5. fix issue that some statements should not be made outside function

/* ---- Grammar ------- */

program ::= declaration_list main|main;

main ::= MAIN LBRACE statement_list_main RBRACE SEMI;

//Types
type ::= DICT LT type COMMA type GT
        | SEQ LT type GT
        | SET LT type GT
        | CHAR
        | INT
        | RAT
        | FLOAT
        | IDENTIFIER
        | TOP
        | BOOL
        ;

// Expression
operator ::= PLUS
          | MINUS
          | MULT
          | DIV
          | EXPO
          | AND
          | OR
          | EQ
          | LT
          | GT
          | LTEQ
          | GTEQ
          | NOTEQ
          | CONCAT
          | PIPE
          | INTERSECTION
          | DIFFERENCE
          | IN
//          | DOT
          ;


//Statements
expression ::= expression operator expression
             | NOT expression
             | LPAREN expression expression_list RPAREN
             | LBRACE expression expression_list RBRACE //SET_LIT
             | LBRACK expression expression_list RBRACK //SEQ_LIT
             | TRUE
             | FALSE
             | expression DOT IDENTIFIER
             | function_call
             | expression indexCall
             | lambda
             | MINUS expression
             | FLOAT_LIT
             | INT_LIT
             | RAT_LIT
             | STRING_LIT
             | CHAR_LIT
             | IDENTIFIER
             |;

declaration ::= type_and_id SEMI
            | assignment SEMI
            | multithreading SEMI
            | tdef SEMI
            | fdef SEMI
            | alias SEMI
            ;

base_statement ::= looping
                | read SEMI
                | print SEMI
                | return_statement SEMI
                | declaration
                | function_call SEMI
                | lambda SEMI
                ;

main_statement ::= base_statement
                | if_statement
                | RETURN SEMI
                ;

statement ::= base_statement
            | if_statement
            | RETURN expression SEMI
            ;

statement_with_break ::= base_statement
            | if_statement_break
            | break
            | RETURN expression SEMI
            ;

type_and_id ::= type IDENTIFIER;

tdef ::= TDEF IDENTIFIER LBRACE type_and_id param_list RBRACE; //TODO add to assumptions, tdef body cannot be empty -> like C99, there is nothing you can do with it so no point

fdef ::= FDEF IDENTIFIER LPAREN RPAREN lbrace_statement_list
        | FDEF type_and_id LPAREN RPAREN lbrace_statement_list
        | FDEF IDENTIFIER LPAREN type_and_id param_list RPAREN lbrace_statement_list
        | FDEF type_and_id LPAREN type_and_id param_list RPAREN lbrace_statement_list
        | FUNC IDENTIFIER ASSIGN lambda
        ;

alias ::= ALIAS type_and_id; //TODO ATA, you can only type alias you cannot alias expressions

lambda ::= PIPE IDENTIFIER id_list PIPE ARROW expression
        | PIPE IDENTIFIER id_list PIPE ARROW lbrace_statement_list
        ;

assignment ::= type_and_id ASSIGN expression expression_list| IDENTIFIER ASSIGN expression expression_list;



// Collection accessing
indexCall ::= LBRACK expression RBRACK
    | LBRACK expression COLON expression RBRACK
    ;


// Declarations

read ::= READ IDENTIFIER;
print ::= PRINT expression;
multithreading ::= THREAD IDENTIFIER ASSIGN lbrace_statement_list;


// Dealing with break
break ::= BREAK SEMI | BREAK INT_LIT SEMI;

if_statement ::= IF LPAREN expression RPAREN THEN statement_list elif FI
             | IF LPAREN expression RPAREN THEN statement_list elif ELSE statement_list FI
             ;

if_statement_break ::= IF LPAREN expression RPAREN THEN statement_list_with_break  elif_break FI
                    | IF LPAREN expression RPAREN THEN statement_list_with_break elif_break ELSE statement_list_with_break FI
                    ;

elif ::= ELIF LPAREN expression RPAREN THEN statement_list elif
        |
        ;

elif_break ::= ELIF LPAREN expression RPAREN THEN statement_list_with_break elif_break
            |
            ;

looping ::= FORALL LPAREN expression RPAREN DO statement_list OD
                | WHILE expression DO statement_list_with_break OD
                ;

// Functions
function_call ::= IDENTIFIER LPAREN expression expression_list RPAREN;



// Literals

//Lists
param_list_helper ::= type_and_id param_list;
param_list ::= COMMA param_list_helper
            |
            ;

statement_list_with_break ::= statement_with_break statement_list_with_break | statement_with_break;
statement_list ::= statement statement_list | statement;
statement_list_main ::= main_statement statement_list_main | main_statement;

expression_list_helper ::= expression expression_list;
expression_list ::= COMMA expression_list_helper
    |
    ;

declaration_list ::= declaration declaration_list | declaration ;

lbrace_statement_list ::= LBRACE statement_list RBRACE;

id_list_helper ::= IDENTIFIER id_list |;
id_list ::= COMMA id_list_helper
          |
          ;