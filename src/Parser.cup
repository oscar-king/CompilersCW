/* ----------------------Preliminary Declarations Section--------------------*/
import java_cup.runtime.*;

/* Parser code to change the way the parser reports errors (include
   line and column number of the error). */
parser code {:
    public boolean syntaxErrors;

    public void syntax_error(Symbol current_token) {
        syntaxErrors = true;
            report_error( "Syntax error at line " + (current_token.left+1) + ", column " + current_token.right + " " + current_token.value + "\n", null);
    }
:};



/* ------------Declaration of Terminals and Non Terminals Section----------- */

//Data Types
terminal           INT, BOOL, RAT, FLOAT, CHAR, DICT, SEQ, SET;

//Other keywords
terminal           THREAD, TOP, FUNC, TDEF, FDEF, RETURN, ALIAS;

//Loops
terminal           IF, FI, THEN, ELSE, WHILE, DO, OD, ELIF, FORALL, IN, BREAK;

//Built in functions
terminal           READ, PRINT, MAIN;

//Operators
terminal           ASSIGN, ARROW, NOT, AND, OR, TRUE, FALSE, INTERSECTION, PIPE, DIFFERENCE, CONCAT;
terminal           NOTEQ, EQ, LT, GT, LTEQ, GTEQ;
terminal           PLUS, MINUS, MULT, DIV, EXPO;

//Punctuation
terminal           LPAREN, RPAREN, LBRACE, RBRACE, LBRACK, RBRACK, SEMI, COLON, COMMA, DOT;

//Literals
terminal           IDENTIFIER, INT_LIT, CHAR_LIT, RAT_LIT, STRING_LIT, FLOAT_LIT;

//High Level
nonterminal        program, main, statement_list, identifier, idWithIndex;

//Declarations
nonterminal        declaration, type_and_id, var_assignment, tdef, fdef, alias, lambda, set_declaration, dict_declaration, seq_declaration;

//Types
non terminal       type, dicttype, seqtype;

//Lists
nonterminal        expression_list, declaration_list, statements_with_break;
nonterminal        arg_list, args, param_list, params;

//literals
non terminal       dict_lit, seq_lit, boolean, number, set_lit;

//Loops
non terminal       do, forall, while, break,  do_with_break, looping;

//Statements and expressions
non terminal       function_call, return_type, if_statement, if_statement_break,return_statement, statement_with_break, body_with_break;
non terminal       dictbody, seqbody, statement;
non terminal       expression, operator, multithreading;

//Functions
non terminal       print, read;

//Helpers
nonterminal        idWithIndexHelp, indexCall, field_access, param_list_helper, elif_break, elif, dictbody_helper, expression_list_helper, lbrace_statement_list;

/* ------------Precedences----------- */
precedence nonassoc IDENTIFIER, FLOAT_LIT, RAT_LIT, STRING_LIT, CHAR_LIT, INT_LIT, TRUE, FALSE;
precedence right ASSIGN;
precedence left OR;
precedence left AND;
precedence nonassoc EQ, NOTEQ;
precedence nonassoc LT, LTEQ, GT, GTEQ;
precedence left CONCAT, PIPE, DIFFERENCE, INTERSECTION;
precedence right PLUS, MINUS;
precedence left  MULT, DIV;
precedence right IN, EXPO;
precedence nonassoc NOT;
precedence nonassoc ARROW;
precedence left DOT, LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE;
precedence left INT, DICT, SET, SEQ, FLOAT, RAT, CHAR, BOOL, TOP;
precedence left COMMA, SEMI;

start with program;

//TODO
//Declaration lists -> comma separated

/* ---- Grammar ------- */

program ::= statement_list main|main;

main ::= MAIN LBRACE statement_list RBRACE SEMI;

//Types
type ::= DICT LT type COMMA type GT
        | SEQ LT type GT
        | SET LT type GT
        | CHAR
        | INT
        | RAT
        | FLOAT
        | IDENTIFIER
        | TOP
        | BOOL
        ;

// Expression
operator ::= PLUS
          | MINUS
          | MULT
          | DIV
          | EXPO
          | AND
          | OR
          | EQ
          | LT
          | GT
          | LTEQ
          | GTEQ
          | NOTEQ
          | CONCAT
          | PIPE
          | INTERSECTION
          | DIFFERENCE
          | IN
          | DOT
          ;


//Statements
expression ::= expression operator expression
             | NOT expression
             | LPAREN expression RPAREN
//             | LPAREN dictbody RPAREN
             | LBRACE expression expression_list RBRACE //SET_LIT
             | LBRACK expression expression_list RBRACK //SEQ_LIT
             | TRUE
             | FALSE
//             | expression DOT IDENTIFIER
             | function_call
             | expression indexCall
//             | lambda
             | MINUS expression
             | FLOAT_LIT
             | INT_LIT
             | RAT_LIT
             | STRING_LIT
             | CHAR_LIT
             | IDENTIFIER
             |;

statement ::= looping
            | if_statement
            | read SEMI
            | print SEMI
            | type_and_id SEMI
            | var_assignment SEMI
            | return_statement SEMI
            | multithreading SEMI
            | tdef SEMI
            | fdef SEMI
            | set_declaration SEMI
            | dict_declaration SEMI
            | seq_declaration SEMI
            | alias SEMI
            | function_call SEMI
            | RETURN expression SEMI
            ;

statement_with_break ::= looping
            | if_statement_break
            | read SEMI
            | print SEMI
            | type_and_id SEMI
            | var_assignment SEMI
            | return_statement SEMI
            | multithreading SEMI
            | tdef SEMI
            | fdef SEMI
            | set_declaration SEMI
            | dict_declaration SEMI
            | seq_declaration SEMI
            | alias SEMI
            | function_call SEMI
            | break
            | RETURN expression SEMI
            ;

type_and_id ::= type IDENTIFIER;

tdef ::= TDEF IDENTIFIER LBRACE type_and_id param_list RBRACE; //TODO add to assumptions, tdef body cannot be empty -> like C99, there is nothing you can do with it so no point

fdef ::= FDEF type_and_id LPAREN type_and_id param_list RPAREN lbrace_statement_list
        | FDEF IDENTIFIER LPAREN type_and_id param_list RPAREN lbrace_statement_list
        | FDEF IDENTIFIER LPAREN RPAREN lbrace_statement_list
        | FDEF type_and_id IDENTIFIER LPAREN RPAREN lbrace_statement_list
        | FUNC IDENTIFIER ASSIGN lambda
        ;

alias ::= ALIAS type_and_id; //TODO ATA, you can only type alias you cannot alias expressions

lambda ::= PIPE expression expression_list PIPE ARROW expression
        | PIPE expression expression_list PIPE ARROW LBRACE statement_list RBRACE
        ;

var_assignment ::= type_and_id ASSIGN expression expression_list| IDENTIFIER ASSIGN expression expression_list;



// Collection accessing
indexCall ::= LBRACK expression RBRACK
    | LBRACK expression COLON expression RBRACK
    ;

// Values

//dict_lit ::= LPAREN dictbody RPAREN;

seq_lit ::= LBRACK expression expression_list_helper RBRACK
           | STRING_LIT;

// Declarations

read ::= READ IDENTIFIER;
print ::= PRINT expression;
multithreading ::= THREAD IDENTIFIER ASSIGN lbrace_statement_list;


// Dealing with break
break ::= BREAK SEMI | BREAK INT_LIT SEMI;

if_statement ::= IF LPAREN expression RPAREN THEN statement_list FI
             | IF LPAREN expression RPAREN THEN statement_list elif ELSE statement_list FI
             ;

if_statement_break ::= IF LPAREN expression RPAREN THEN statements_with_break FI
                    | IF LPAREN expression RPAREN THEN statements_with_break elif_break ELSE statements_with_break FI
                    ;

elif ::= ELIF LPAREN expression RPAREN THEN statement_list elif
        |
        ;

elif_break ::= ELIF LPAREN expression RPAREN THEN statements_with_break elif_break
            |
            ;

looping ::= FORALL LPAREN expression RPAREN DO statement_list OD
                | WHILE expression DO statements_with_break OD
                ;

//Declarations

set_declaration ::= SET LT type GT IDENTIFIER
                | SET LT type GT IDENTIFIER ASSIGN expression
                ;

dict_declaration ::= DICT LT type COMMA type GT IDENTIFIER;

seq_declaration ::= SEQ LT type GT IDENTIFIER;


// Functions
function_call ::= IDENTIFIER LPAREN expression expression_list RPAREN;



// Literals

//dict_lit ::= LPAREN expression COLON expression dictbody RPAREN
//          | LPAREN RPAREN
//          ;

//Lists
param_list_helper ::= type_and_id param_list;
param_list ::= COMMA param_list_helper
            |
            ;

dictbody_helper ::= expression COLON expression dictbody |;
dictbody ::= COMMA dictbody_helper
    |
    ;

statements_with_break ::= statement_with_break statements_with_break | statement_with_break;
statement_list ::= statement statement_list | statement;

expression_list_helper ::= expression expression_list;
expression_list ::= COMMA expression_list_helper
    |
    ;

lbrace_statement_list ::= LBRACE statement_list RBRACE;